* This do file run the regression specification in Yawen's "Does Trade Liberalization Induce Occupational Movement?"
* and then compute the conterfacural as if there were no trade opening
* The regression part is from "regressionsYawen_15Oct28.do"
* After the regression, get the predicted values with and without the trade shock 


* input data are generated by "regressionsYawen_15Oct28.do"

* Last updated: Oct 28th,2015


set more off
cd "C:\PhD Study\Year 3\Projects\Job Porlarization\Arranged Files"
clear


use "data\temp\HHOct28_temp.dta",clear /* generated by regressionsYawen_15Oct28.do */
keep if year==1990|year==1996|year==1997|year==2002|year==2006

* generate region-group variables
ren l L_kabgrp

foreach item in abstract routine manual{
gen `item'_shr_grp = `item'/L_kabgrp  /* occupation shares within groups */
gen ln`item'_shr_grp = ln(`item'_shr_grp)
}

* generate regional variables

bys year code1990: egen L_kab = sum(L_kabgrp)
foreach item in abstract routine manual{
bys year code1990: egen `item'_kab=sum(`item')
gen `item'_shr_kab = `item'_kab/L_kab
}
foreach num of numlist 1/4{
bys year code1990: egen grp`num'_kab = sum(grp`num')
gen lngrp`num'_kab = ln(grp`num'_kab)
*gen grp`num'_shr = grp`num'_kab/L_kab
}

* generate changes
gen id = code1990*10+grp
xtset id year

gen Y1 = routine_shr_grp/abstract_shr_grp
gen Y2 = routine_shr_grp/manual_shr_grp

foreach Y in Y1 Y2{
gen ln`Y' = ln(`Y')
gen dln`Y' = ln`Y'-L6.ln`Y' if year==1996
replace dln`Y' = ln`Y'-L4.ln`Y' if year==2006
gen L`Y' = L6.`Y' if year==1996
replace L`Y' = L4.`Y' if year==2006
}

gen LL_kabgrp = L6.L_kabgrp if year==1996
replace LL_kabgrp = L4.L_kabgrp if year==2006

foreach num of numlist 1/4{
gen dlngrp`num'_kab = lngrp`num'_kab-L6.lngrp`num'_kab if year==1996
replace dlngrp`num'_kab = lngrp`num'_kab-L4.lngrp`num'_kab if year==2006
}

foreach item in abstract routine manual{
gen L`item'_shr_kab = L6.`item'_shr_kab if year==1996
replace L`item'_shr_kab = L4.`item'_shr_kab if year==2006
}

gen prov1990 = int(code1990/100)
keep if year==1996|year==2006
merge m:1 code1990 year using "data\output\WITS_kabyr9006bg_15Oct26_CHN.dta" /* generated by Bartik_15Oct26_CHN.do */
keep if _merge==3
drop _merge
save "data\temp\regression_Oct28_CHN.dta",replace

foreach task in a r m{
ren delta_`task'_kab delta_`task'
replace delta_`task'=delta_`task'*100
}

foreach part in WLD noCHN{
foreach task in a r m{
gen delta_`task'Xdlnnx`part'_`task'_kab = delta_`task'*dlnnx`part'_`task'_kab
gen delta_fullXdlnnx`part'_`task'_kab = delta_a*delta_r*delta_m*dlnnx`part'_`task'_kab
gen LmXdelta_`task'Xdlnnx`part'_`task'_kab = Lmanual_shr_kab*delta_`task'Xdlnnx`part'_`task'_kab
gen LaXdelta_`task'Xdlnnx`part'_`task'_kab = Labstract_shr_kab*delta_`task'Xdlnnx`part'_`task'_kab
}
}

* generate interactions with the supply shocks
foreach item in a r m{
foreach num of numlist 1/4{
gen delta_`item'Xdlngp`num' = delta_`item'*dlngrp`num'
}
}

foreach num of numlist 1/4{
gen LmXdlngp`num' = Lmanual_shr_kab*dlngrp`num'
gen LaXdlngp`num' = Labstract_shr_kab*dlngrp`num'
}

set more off
****1. Short periods
global delta delta_a delta_r delta_m

* regressor set 1 (change in log)
global dlnx dlngrp*
global deltaXdlnx delta_*dlngp*
global dlnnxWLD dlnnxWLD_a_kab dlnnxWLD_r_kab dlnnxWLD_m_kab
global deltaXdlnnxWLD delta_aXdlnnxWLD_a_kab delta_rXdlnnxWLD_r_kab delta_mXdlnnxWLD_m_kab
global deltaXdlnnxWLD_full delta_fullXdlnnxWLD_a_kab delta_fullXdlnnxWLD_r_kab delta_fullXdlnnxWLD_m_kab 

* pick the regressor set
global Y1 dlnY1 /* options: dlnY1 pctdY1 */
global Y2 dlnY2 /* options: dlnY2 pctdY2 */
 
global X1 $dlnnxWLD /* options: $dlnYwtnxWLD $pctdYwtnxWLD */
global X2 $deltaXdlnnxWLD /* options: $deltaXdlnYwtnxWLD $deltaXpctdYwtnxWLD */
global cX2 c.delta_aXdlnnxWLD_a_kab c.delta_rXdlnnxWLD_r_kab c.delta_mXdlnnxWLD_m_kab
global X3 $deltaXdlnnxWLD_full /* options: $deltaXdlnYwtnxWLD_full $$deltaXpctdYwtnxWLD_full */

global X4 $dlnx /* options: $dlnx $pctdx */
global X5 $deltaXdlnx /* options: $deltaXdlnx $deltaXpctdx */
global X6 Lmanual_shr_kab
global X7 Labstract_shr_kab
global X8 LmXdelta_*XdlnnxWLD_*_kab
global X9 LaXdelta_*XdlnnxWLD_*_kab
duplicates tag code1990 grp,gen(dup)
keep if dup==1

* 2. IV

* 2.1 IV estimations (log changes)

* use distance to port, distance to airport, port dummies and related interactions to instrument the three shocks
merge m:1 code1990 using "data\output\distances_code1990.do"
drop if _merge==2

foreach task in a r m{
gen delta_`task'Xdist_port = delta_`task'*cdist_port
gen delta_`task'Xdist_airport = delta_`task'*cdist_airport
gen delta_`task'Xdport = delta_`task'*dport
gen delta_`task'Xdaport = delta_`task'*daport

gen delta_`task'Xdlntariff_`task'_kab = delta_`task'*dlntariff_`task'_kab
gen delta_fullXdlntariff_`task'_kab = delta_a*delta_r*delta_m*dlntariff_`task'_kab
}

*IV set 

global IV1 delta_aXdlntariff_a_kab delta_rXdlntariff_r_kab delta_mXdlntariff_m_kab
global IV2 delta_fullXdlntariff_a_kab delta_fullXdlntariff_r_kab delta_fullXdlntariff_m_kab
global IV3 cdist_port cdist_airport dport daport

set more off

* (include distances)
levelsof year, local(yr)
foreach pd in `yr'{
ivregress 2sls dlnY1 ($X2 $X3 = $IV1 $IV2 $IV3) $X4 $X5 $X6 i.prov i.grp if year==`pd', cluster(code1990)
predict dlnY1_hat`pd' if year==`pd'
*replace dlnY1_hat`pd' = dlnY1_hat`pd'/100

foreach task in a r m{
gen temp`task' = delta_`task'XdlnnxWLD_`task'_kab
gen temp`task'_full = delta_fullXdlnnxWLD_`task'_kab
replace delta_`task'XdlnnxWLD_`task'_kab=0 if temp`task'!=.
replace delta_fullXdlnnxWLD_`task'_kab=0 if temp`task'_full!=.
}

predict dlnY1_hat`pd'_ctf if year==`pd'
*replace dlnY1_hat`pd'_ctf = dlnY1_hat`pd'_ctf/100 /* the regression was run with (1-\delta)*100 */
foreach task in a r m{
replace delta_`task'XdlnnxWLD_`task'_kab = delta_`task'XdlnnxnoCHN_`task'_kab if temp`task'!=.
replace delta_fullXdlnnxWLD_`task'_kab =  delta_fullXdlnnxnoCHN_`task'_kab if temp`task'_full!=.
}

predict dlnY1_hat`pd'_noCHN if year==`pd'

foreach task in a r m{
replace delta_`task'XdlnnxWLD_`task'_kab = temp`task'
replace delta_fullXdlnnxWLD_`task'_kab = temp`task'_full
}

drop temp*
}


foreach pd in `yr'{
ivregress 2sls $Y2 ($X2 $X3 = $IV1 $IV2 $IV3) $X4 $X5 $X7 i.prov i.grp if year==`pd', cluster(code1990)
predict dlnY2_hat`pd' if year==`pd'
replace dlnY2_hat`pd'=dlnY2_hat`pd'/100 /* the regression was run with (1-\delta)*100 */

foreach task in a r m{
gen temp`task' = delta_`task'XdlnnxWLD_`task'_kab
gen temp`task'_full = delta_fullXdlnnxWLD_`task'_kab
replace delta_`task'XdlnnxWLD_`task'_kab=0 if temp`task'!=.
replace delta_fullXdlnnxWLD_`task'_kab=0 if temp`task'_full!=.
}
predict dlnY2_hat`pd'_ctf if year==`pd'
replace dlnY2_hat`pd'_ctf = dlnY2_hat`pd'_ctf/100 /* the regression was run with (1-\delta)*100 */

foreach task in a r m{
replace delta_`task'XdlnnxWLD_`task'_kab = delta_`task'XdlnnxnoCHN_`task'_kab if temp`task'!=.
replace delta_fullXdlnnxWLD_`task'_kab =  delta_fullXdlnnxnoCHN_`task'_kab if temp`task'_full!=.
}
predict dlnY2_hat`pd'_noCHN if year==`pd'

foreach task in a r m{
replace delta_`task'XdlnnxWLD_`task'_kab = temp`task' 
replace delta_fullXdlnnxWLD_`task'_kab = temp`task'_full
}

drop temp*
}

foreach Y in Y1 Y2{
gen dln`Y'_hat=.
replace dln`Y'_hat = dln`Y'_hat1996 if year==1996
replace dln`Y'_hat = dln`Y'_hat2006 if year==2006

gen dln`Y'_hat_ctf = .
replace dln`Y'_hat_ctf = dln`Y'_hat1996_ctf if year==1996
replace dln`Y'_hat_ctf = dln`Y'_hat2006_ctf if year==2006
gen dln`Y'_trade = dln`Y'_hat-dln`Y'_hat_ctf

gen dln`Y'_hat_noCHN = .
replace dln`Y'_hat_noCHN = dln`Y'_hat1996_noCHN if year==1996
replace dln`Y'_hat_noCHN = dln`Y'_hat2006_noCHN if year==2006
gen dln`Y'_CHN = dln`Y'_hat-dln`Y'_hat_noCHN
}



*keep year code1990 grp id dlnY1 dlnY2 dlnY*_hat dlnY*_hat_ctf LY1 LY2 Y1 Y2 L_kabgrp abstract routine manual
*sum Lr  routine Lm manual Lc abstract if Y1!=.&Y2!=.&(Y1* Y2+Y1+Y2)!=0

keep year code1990 grp id dlnY1 dlnY2 dlnY*_hat dlnY*_hat_ctf dlnY*_hat_noCHN dlnY*_trade dlnY*_CHN LY1 LY2 Y1 Y2 L_kabgrp LL_kabgrp

save "data\temp\ctf.dta",replace

use "data\temp\ctf.dta",clear
* linear prediction is incorrect if dlnY<-1 (relative employment must be positive)
*drop if dlnY1<-1
*drop if dlnY2<-1
*drop if dlnY1==.
*drop if dlnY2==.
*drop if dlnY1_hat==.
*drop if dlnY2_hat==.

* compute the prediction using fitted values
foreach Y in Y1 Y2{
gen `Y'_hat = (1+dln`Y'_hat)*L`Y'
gen `Y'_hat_ctf = (1+dln`Y'_hat_ctf)*L`Y'
gen `Y'_hat_noCHN = (1+dln`Y'_hat_noCHN)*L`Y'
}

* L for "lagged"

gen mocc_shr = Y1/(Y1+Y2+Y1*Y2)
gen rocc_shr = (Y1*Y2)/(Y1+Y2+Y1*Y2)
gen cocc_shr = Y2/(Y1+Y2+Y1*Y2)

gen Lmocc_shr = LY1/(LY1+LY2+LY1*LY2)
gen Lrocc_shr = (LY1*LY2)/(LY1+LY2+LY1*LY2)
gen Lcocc_shr = LY2/(LY1+LY2+LY1*LY2)
 
foreach task in m r c{
gen d`task'occ_shr  = `task'occ_shr-L`task'occ_shr
}

* compute the docc_shr caused by trade
foreach item in hat hat_ctf hat_noCHN{
gen mocc_shr_`item' = Y1_`item'/(Y1_`item'+Y2_`item'+Y1_`item'*Y2_`item')
gen rocc_shr_`item' = (Y1_`item'*Y2_`item')/(Y1_`item'+Y2_`item'+Y1_`item'*Y2_`item')
gen cocc_shr_`item' = Y2_`item'/(Y1_`item'+Y2_`item'+Y1_`item'*Y2_`item')
}


foreach task in m r c{
gen d`task'occ_shr_hat = `task'occ_shr_hat-L`task'occ_shr
gen d`task'occ_shr_hat_ctf = `task'occ_shr_hat_ctf-L`task'occ_shr
gen d`task'occ_shr_hat_noCHN = `task'occ_shr_hat_noCHN-L`task'occ_shr

gen d`task'occ_shr_trade = d`task'occ_shr_hat-d`task'occ_shr_hat_ctf /* total - no trade */
gen d`task'occ_shr_tradeCHN = d`task'occ_shr_hat-d`task'occ_shr_hat_noCHN /* total - no trade with China */

}


collapse (mean) d*occ_shr d*occ_shr_trade d*occ_shr_tradeCHN [aweight=L_kabgrp], by(year)

* compute the share explained by trade
foreach task in m r c{
gen pct_trade`task' = d`task'occ_shr_trade/d`task'occ_shr
}

********************************************************
* Draw the bar graphs
gen period = year
label define periodl 1 "1990-1996" 2 "2002-2006" 3 "1990-2006"
label values period periodl

* aggregated

graph bar dmocc_shr_trade drocc_shr_trade dcocc_shr_trade, over(period,label(labsize(small))) legend (label(1 "Manual Occupations" ) label(2 "Routine Occupations") ///
label(3 "Cognitive Occupations")) ytitle("Change in Employment Share", size(small))  ///
title("Trade Induced Change in Employment Shares by Occupation in Indonesia", size(medsmall)) name(docc_shr_trade,replace) 

* compare with the total change computed by "Pattern9006_15Oct26.do"
keep year d*occ_shr_trade d*occ_shr_tradeCHN
merge 1:1 year using "data\temp\pattern_Nov22.dta"

drop _merge
foreach task in m r c{
ren d`task'occ_shr d`task'occ_shr0
ren d`task'occ_shr_trade d`task'occ_shr1
ren d`task'occ_shr_tradeCHN d`task'occ_shr2
gen d`task'occ_shr3 = d`task'occ_shr0-d`task'occ_shr1 /* domestic */
}

reshape long dmocc_shr drocc_shr dcocc_shr, i(year) j(aggregate)

label define aggregatel 0 "overall" 1 "trade induced" 2 "induced by trade with China"  3 "residual" 
label value aggregate "aggregatel"
keep if year==2006

graph bar dmocc_shr drocc_shr dcocc_shr, over(aggregate,label(labsize(small))) legend (label(1 "Manual Occupations" ) label(2 "Routine Occupations") ///
label(3 "Cognitive Occupations")) ytitle("Change in Employment Share", size(small))  ///
title("Change in Employment Shares by Occupation in Indonesia (2002-2006)", size(medsmall)) name(docc_shr_all,replace) scheme(vg_s2c) graphregion(fcolor(white) lcolor(white))


stop

* by sill levels


label define grpl 1 "skilled-male" 2 "unskilled-male" 3 "skilled-female" 4 "unskilled-female"
label value grp "grpl"

graph bar dmocc_shr_trade drocc_shr_trade dcocc_shr_trade, over(period,label(labsize(small))) legend (label(1 "Manual Occupations" ) label(2 "Routine Occupations") ///
label(3 "Cognitive Occupations")) ytitle("100 x Change in Employment Share", size(small)) ylabel(-0.5 (0.25).5, grid) ///
name(pctdocc_shr_3period,replace) by(grp, noiy title("Change in Occupational Employment Shares by Skill-gender in Indonesia",size(medium small)) ) scheme(s2color)





stop

*****************************************************************************






stop

* lagged variables
gen LLr = (LY1* LY2/(LY1* LY2+LY1+LY2))*LL_kabgrp
gen LLm = (LY1/(LY1* LY2+LY1+LY2))*LL_kabgrp
gen LLc = (LY2/(LY1* LY2+LY1+LY2))*LL_kabgrp

gen Lr = (Y1* Y2/(Y1* Y2+Y1+Y2))*L_kabgrp
gen Lm = (Y1/(Y1* Y2+Y1+Y2))*L_kabgrp
gen Lc = (Y2/(Y1* Y2+Y1+Y2))*L_kabgrp

gen Y1_pred = (1+dlnY1)*LY1
gen Y2_pred = (1+dlnY2)*LY2
*using change log to predit fits the data well:
*twoway (scatter Y1 Y1_pred) (lfit Y1 Y1_pred) if year==2006 
*twoway (scatter Y1 Y1_pred) (lfit Y1 Y1_pred) if year==1996
*twoway (scatter Y2 Y2_pred) (lfit Y2 Y2_pred) if year==2006 
*twoway (scatter Y2 Y2_pred) (lfit Y2 Y2_pred) if year==1996


* compute the prediction using fitted values
foreach Y in Y1 Y2{
gen `Y'_hat = (1+dln`Y'_hat)*L`Y'
gen `Y'_hat_ctf = (1+dln`Y'_hat_ctf)*L`Y'
}

foreach item in hat hat_ctf{
gen Lr_`item' = (Y1_`item'* Y2_`item'/(Y1_`item'* Y2_`item'+Y1_`item'+Y2_`item'))*L_kabgrp
gen Lm_`item' = (Y1_`item'/(Y1_`item'* Y2_`item'+Y1_`item'+Y2_`item'))*L_kabgrp
gen Lc_`item' = (Y2_`item'/(Y1_`item'* Y2_`item'+Y1_`item'+Y2_`item'))*L_kabgrp
}

collapse (sum) Lr* Lm* Lc* LLr LLm LLc L_kabgrp LL_kabgrp, by(year)
ren L_kabgrp L
ren LL_kabgrp LL

******************************************************************************
* Compute the employment share changes: observed, with trade and without trade
******************************************************************************

* L for "lagged"

foreach task in m r c{
gen `task'occ_shr = L`task'/L
gen L`task'occ_shr = LL`task'/LL
gen d`task'occ_shr  = `task'occ_shr-L`task'occ_shr
}

* compute the docc_shr caused by trade
foreach task in m r c{
foreach item in hat hat_ctf {
gen `task'occ_shr_`item' = L`task'_`item'/L
gen d`task'occ_shr_`item' = `task'occ_shr_`item'-L`task'occ_shr
}
}

foreach task in m r c{
gen d`task'_occ_shr_trade = d`task'occ_shr_hat-d`task'occ_shr_hat_ctf
}

keep year d*occ_shr d*_occ_shr_trade
*keep year grp d*occ_shr d*_occ_shr_trade d*occ_shr_hat d*occ_shr_hat_ctf














